#!/usr/bin/env bash

set -euo pipefail
set -o nounset
shopt -s lastpipe

if [[ "${TRACE-0}" == "1" ]]; then
    set -o xtrace
fi


# If this script is executed via a symlink SYM_SCRIPTNAME is the symlink's name.
readonly SYM_SCRIPTNAME="${0##*/}"

# Whereas this is the real terminal file-name of the current script.
readonly REAL_SCRIPTNAME="$(realpath "${BASH_SOURCE:-0}";)"

# Where the real scriptname (us) is located.
readonly BENCHY_LOC="$(dirname -- "$REAL_SCRIPTNAME")"

# Save where we are and make sure we're at Benchy's location.
# printf 'benchy at: %s\n' "$BENCHY_LOC"
pushd "$(pwd)" 1> /dev/null
pushd "$BENCHY_LOC" 1> /dev/null

# So we can image ourselves later save variable and function definition state before (later we'll diff against this to export the appropriate things).
readonly __BENCHY_VARS_BEFORE="$(declare -p | awk '$3 !~ /__BENCHY/ { gsub(/=.*$/, "", $3); print $3; }' | grep -v '^$' | sort)"
readonly __BENCHY_FUNS_BEFORE="$(declare -pF | awk '{ print $3; }' | grep -v '^$' | sort)"

# Because we're going to source a bunch of files which are relative to us and it's easier if we just cd instead of prefixing every possible path.
source 'harness/stdlib.sh'
source 'harness/suite.sh'
source 'harness/container.sh'

readonly __BENCHY_VARS_AFTER="$(declare -p | awk '$3 !~ /__BENCHY/ { gsub(/=.*$/, "", $3); print $3; }' | grep -v '^$' | sort)"
readonly __BENCHY_FUNS_AFTER="$(declare -pF | awk '{ print $3; }' | grep -v '^$' | sort)"

readonly __BENCHY_VARS_IMAGE="$(comm -13 <(printf '%s\n' "$__BENCHY_VARS_BEFORE") <(printf '%s\n' "$__BENCHY_VARS_AFTER"))"
readonly __BENCHY_FUNS_IMAGE="$(comm -13 <(printf '%s\n' "$__BENCHY_FUNS_BEFORE") <(printf '%s\n' "$__BENCHY_FUNS_AFTER"))"


usage ()
{
    printf '%s' "\
Benchy -- a test harness to benchmark all the ZK stacks!

DESCRIPTION
    Benchy will execute pre-defined fixtures and record various metrics like
    wall (real) execution time, peak memory usage, and other perf_event_open(2)
    metrics. Additional properties like witness, and proof sizes are recorded.

"

    if [[ "$invoked_as" == 'make' ]]; then
        printf '%s' "\
SYNOPSIS
    make
"
    else
        printf '%s' "\
SYNOPSIS
    ./$invoked_as
    ./$invoked_as [OPTIONS] [COMMAND]

COMMANDS
    list                  list known benchmark suites and their scenarios
    make                  build containers for benchmarking
    run                   start benchmarking

OPTIONS
    -h, --help            print this help message
    -v, --version         print Benchy version number (semver)

NOTE
    Benchy can be called via the provided GNU-flavoured Make Makefile
    however it accepts absolutely no options in that case; i.e. the only
    valid command is \`make\`.
"
    fi
}


version ()
{
    printf '%s' "\
Benchy (ZK Benchmarks) 0.1.0
"
  exit 0
}


# Pretend we're some kind of lisp and image ourself (Benchy) into the container with only the fixtures to be run.
benchy_image ()
{
    alert 'Imaging Benchy for:' " $1"

    declare -r context="suite/${1}/build__${2}"
    declare -r benchy_imaged="$context/benchy_imaged.sh"
    
    # Temporary for building.
    if [[ ! -d "$context" ]]; then
        mkdir "$context"
    fi

    rm -rf "$context"/*

    # XXX: Will conflict with downloaded scenarios, change handling with Ruby rewrite.
    # Add pre-provided scenarios (if any).
    if [[ -d "suite/${1}/${2}"_benchmarks ]]; then
        cp -a "suite/${1}/${2}"_benchmarks "$context"
    fi

    cp -a harness/install/* "$context"
    cp -a "suite/${1}/${2}.sh" "$context"
    chmod +x "$context/${2}.sh"
    cp -a "suite/${1}/${2}.Containerfile" "$context"

    # TODO: Get these from current shell, as right now gotta keep them in-sync.
    tee "$benchy_imaged" <<EOF > /dev/null
#!/usr/bin/env bash

set -euo pipefail
set -o nounset
shopt -s lastpipe

if [[ "${TRACE-0}" == "1" ]]; then
    set -o xtrace
fi

EOF

    # Dump variables.
    while IFS= read -r bvar; do
        declare -p "$bvar" >> "$benchy_imaged"
    done <<< "$__BENCHY_VARS_IMAGE"

    # Dump functions.
    while IFS= read -r bfun; do
        declare -f "$bfun" >> "$benchy_imaged"
    done <<< "$__BENCHY_FUNS_IMAGE"
}


benchy_list ()
{
    puts "${#suites[@]} benchmark suites found"
    puts
    
    for s in "${!suites[@]}"; do
        declare sv="${suites[$s]}"
        declare -n sv_ptr="$sv"
        
        puts "    $s (${#sv_ptr[@]} defs)"
        for sd in "${sv_ptr[@]}"; do
            puts "      $sd"
        done; unset sd
        puts
        
        unset -n sv
        unset -n sv_ptr
    done; unset -n s
}


benchy_make ()
{
    alert 'Suites to build:'
    benchy_list
    # list_enabled

    # XXX: Yes, for now we'll do it serially. YSH/Zig split it up over N cores and build as much in parallel as possible.
    for s in "${!suites[@]}"; do
        declare sv="${suites[$s]}"
        declare -n sv_ptr="$sv"
        
        for sd in "${sv_ptr[@]}"; do
            benchy_image "$s" "$sd"
            call make_container "$s" "$sd"
        done; unset sd
        
        unset -n sv
        unset -n sv_ptr
    done; unset -n s
}


benchy_run ()
{
    alert 'Suites to run:'
    benchy_list

    for s in "${!suites[@]}"; do
        declare sv="${suites[$s]}"
        declare -n sv_ptr="$sv"
        
        for sd in "${sv_ptr[@]}"; do
            call run_container "$s" "$sd"
        done; unset sd
        
        unset -n sv
        unset -n sv_ptr
    done; unset -n s
}


main ()
{
    if [[ "$(ps -co comm= "$PPID")" == 'make' ]]; then
        invoked_as='make'
    else
        invoked_as="${0##*/}"
    fi

    # No arguments = print help.
    [[ "$#" -eq 0 ]] && {
        usage
        exit 0
    }

    # All options are mutually exclusive so this is fine.
    [[ "$#" -gt 1 ]] && {
        die 'Too many options, pass only `-h` or `--help` for usage.'
    }

    # Ditto above.
    case "$1" in
        list)
            benchy_list
            ;;

        make)
            call benchy_make
            ;;

        run)
            call benchy_run
            ;;

        -v|--version)
            version
            exit 0
            ;;

        -h|--help)
            usage
            exit 0
            ;;

        *)
            error "Invalid option: " "$1"
            printf '\n'
            usage
            exit 1
            ;;
    esac
}

main "$@"

popd 1> /dev/null
